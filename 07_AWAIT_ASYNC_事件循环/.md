# async await

#### 基本使用
![](../picture/03/1.png)

###### 基本概念

1.  **async 关键字**:

    -   当你用 async 关键字声明一个函数时，这个函数会自动返回一个 Promise 对象。
    -   即使函数内部没有显式返回一个 Promise，或者只是返回一个普通值（如数字、字符串），async 函数也会将这个返回值包装在一个已解决（resolved）的 Promise 中。
    -   如果函数内部抛出一个错误，async 函数会返回一个被拒绝（rejected）的 Promise，并将错误作为拒绝的原因。

1.  **await 关键字**:

    -   await 关键字只能在 async 函数内部使用（或者在现代 JavaScript 模块的顶层）。
    -   它用于等待一个 Promise 对象。当 JavaScript 引擎遇到 await 时，它会暂停当前 async 函数的执行，等待 await 后面的 Promise 解决（resolve）或拒绝（reject）。
    -   如果 Promise 解决，await 表达式会返回 Promise 的解决值。
    -   如果 Promise 拒绝，await 表达式会抛出 Promise 的拒绝原因（通常是一个 Error 对象）。你可以使用 try...catch 块来捕获这个错误。
    -   重要的是，当 async 函数因为 await 而暂停时，JavaScript 引擎并不会阻塞整个程序，而是可以去执行其他任务（事件循环机制）。

###### 为什么使用 async await

1.  **可读性强**：异步代码看起来更像同步代码，逻辑更清晰，易于理解和维护。
2.  **错误处理简单**：可以使用标准的 try...catch 结构来捕获来自 await 表达式（即 Promise 拒绝）的错误，这比 Promise 链中的 .catch() 更直观。
3.  **避免回调地狱 (Callback Hell)** ：相比于传统的回调函数嵌套，async/await 极大地扁平化了代码结构。
4.  **调试方便**：在调试器中，可以像同步代码一样单步执行 await 语句。

###### 关键的

-   async 函数总是返回一个 Promise。
-   await 只能在 async 函数内部使用（或模块顶层）。
-   await 会暂停 async 函数的执行，但不会阻塞整个 JavaScript 线程。
-   使用 try...catch 来处理 await 表达式可能抛出的错误。
-   async/await 是 Promise 的语法糖，底层仍然是 Promise 在工作。

#### 不同情况的基本使用

```js
// fun 1
async function foo1() {
  console.log('foo')
}

// fun 2
const foo2 = async function () {
  console.log('foo2')
}
// fun 3
const foo3 = async () => {
  console.log('foo3')
}

// fun 4
class Person{
  async foo5() {
    console.log('foo5')
  }
}
```

#### async 的返回值 四种 种的情况

1.  **返回一个非 Promise 值 (例如：数字、字符串、对象、undefined、null)**

    -   async 函数会自动将这个返回值包装在一个**已解决 (resolved)** 的 Promise 中。
    -   Promise 的解决值为你 return 的那个值。

    ```js
    async function getValue() {
      return 42; // 返回一个数字
    }

    getValue().then(value => {
      console.log(value); // 输出: 42
      console.log(getValue() instanceof Promise); // 输出: true
    });

    async function getUndefined() {
      // 没有显式 return，或者 return; 或者 return undefined;
    }

    getUndefined().then(value => {
      console.log(value); // 输出: undefined
    });

    async function getNull() {
      return null;
    }

    getNull().then(value => {
      console.log(value); // 输出: null
    });
        
    ```

1.  **返回一个 Promise 对象**

    -   如果 async 函数内部显式 return 了一个 Promise 对象，那么 async 函数的返回值就是**这个 Promise 对象本身**。它不会再进行额外的包装。
    -   这个返回的 Promise 的状态（resolved 或 rejected）和值/原因将直接决定 async 函数返回的 Promise 的状态和值/原因。

    ```js
    async function getPromiseResolved() {
      return Promise.resolve("Hello from Promise!");
    }

    getPromiseResolved().then(message => {
      console.log(message); // 输出: Hello from Promise!
    });

    async function getPromiseRejected() {
      return Promise.reject(new Error("Something went wrong in Promise!"));
    }

    getPromiseRejected()
      .then(value => console.log("Success:", value)) // 不会执行
      .catch(error => {
        console.error("Error:", error.message); // 输出: Error: Something went wrong in Promise!
      });

    async function getAwaitedPromise() {
      const p = new Promise(resolve => setTimeout(() => resolve("Awaited and resolved"), 100));
      return await p; // await 会解包 Promise，然后 async 再次包装
                      // 实际上，如果 return 的是 await p，等同于直接 return p
                      // 更准确地说，return await p; 会先等待 p 解决，
                      // 然后将 p 的解决值作为当前 async 函数的解决值进行包装返回。
                      // 如果 p 拒绝，则当前 async 函数返回的 Promise 也拒绝。
    }

    getAwaitedPromise().then(value => {
        console.log(value); // 输出: Awaited and resolved
    });
        
    ```


    **注意**: return await promise; 和 return promise; 在大多数情况下行为相似，但有一个细微差别：

    -   return promise;: 立即返回 promise。如果 promise 最终拒绝，调用者直接处理这个拒绝。
    -   return await promise;: 会等待 promise 解决或拒绝。如果 promise 拒绝，这个拒绝会像在 async 函数内部抛出错误一样，可以被 async 函数自身的 try...catch 捕获（如果外部没有 try...catch 包裹 await 的话）。最终 async 函数还是会返回一个新的 Promise，其状态与 promise 一致。

1.  **函数内部抛出错误 (throw new Error())**

    -   如果 async 函数内部（包括 await 表达式等待的 Promise 被拒绝且未被 try...catch 捕获时）抛出了一个错误，那么 async 函数会返回一个**被拒绝 (rejected)** 的 Promise。
    -   Promise 的拒绝原因就是抛出的那个错误对象。

    ```js
    async function throwError() {
      throw new Error("Intentional error!");
    }

    throwError()
      .then(value => console.log("Success:", value)) // 不会执行
      .catch(error => {
        console.error("Caught error:", error.message); // 输出: Caught error: Intentional error!
      });

    async function awaitRejectedPromise() {
      const p = Promise.reject(new Error("Awaited promise rejected!"));
      try {
        await p; // 这里会抛出错误
      } catch (err) {
        console.error("Caught internally:", err.message); // 可以内部捕获
        return "Recovered from error"; // 如果捕获并返回，则 async 函数返回 resolved Promise
      }
      // 如果没有 try...catch，错误会使 async 函数返回 rejected Promise
      // await p; // 如果这样写，且 p reject，则 async 函数返回 rejected Promise
    }

    awaitRejectedPromise().then(result => {
        console.log("Result of awaitRejectedPromise:", result); // 输出: Result of awaitRejectedPromise: Recovered from error
    });

    async function awaitRejectedPromiseNoCatch() {
        const p = Promise.reject(new Error("Awaited promise rejected, no catch!"));
        await p; // 这会导致 async 函数返回一个 rejected Promise
        console.log("This will not be reached"); // 不会执行
        return "Success"; // 不会执行
    }

    awaitRejectedPromiseNoCatch()
        .then(val => console.log("Success:", val))
        .catch(err => console.error("Caught externally:", err.message)); // 输出: Caught externally: Awaited promise rejected, no catch!
        
    ```


1.  **没有 return 语句（或者只有 return;）**

    -   与普通函数一样，如果 async 函数执行完毕而没有遇到显式的 return value; 语句（或者只有空的 return;），它会隐式返回 undefined。
    -   因此，async 函数会返回一个**已解决 (resolved)** 的 Promise，其解决值为 undefined。

    ```js
    async function noReturnValue() {
      console.log("Async function executed.");
      // 隐式 return undefined;
    }

    noReturnValue().then(value => {
      console.log(value); // 输出: undefined
    });
        
    ```


**总结表格：**

| async 函数内部操作                        | 返回的 Promise 状态       | Promise 的值/原因                  |
| ----------------------------------- | -------------------- | ------------------------------ |
| return `<non-promise-value>`;         | Resolved             | `<non-promise-value>`  
| return `<promise-object>`;            | (同 `<promise-object>`) | (同 `<promise-object>` 的解决值或拒绝原因) |
| throw `<error-object>`;               | Rejected             | `<error-object>`                 |
| await `<rejected-promise>`; (未捕获)     | Rejected             | `<rejected-promise>` 的拒绝原因       |
| 执行完毕，无显式 return `<value>`; (或return;) | Resolved             | undefined                      |

# await 

![](../picture/03/2.png)

#### 1. 基本语法和前提

-   **必须在 async 函数中使用**：await 只能在声明为 async 的函数内部使用。

    ```js
    async function myFunction() {
      // 你可以在这里使用 await
    }

    // 或者 async 箭头函数
    const myArrowFunction = async () => {
      // 你可以在这里使用 await
    };
        
    ```

    例外：在现代 JavaScript 模块的顶层，可以直接使用 await（称为 "top-level await"），但这通常用于模块初始化等场景。

-   **await 操作符后通常跟一个 Promise 对象**：

    ```js
    async function fetchData() {
      console.log("开始获取数据...");
      //假设 someAsyncOperation() 返回一个 Promise
      const data = await someAsyncOperation(); // 函数会在此暂停，直到 Promise 解决
      console.log("数据已获取:", data);
      return data;
    }
        
    ```


#### **2. await 的作用**

-   **暂停执行**：当 async 函数执行到 await 表达式时，它会暂停该 async 函数的执行。

-   **等待 Promise**：它会等待 await 右侧的 Promise 对象的状态改变。

    -   如果 Promise resolve（成功），await 表达式会返回 Promise 的 resolved 值。
    -   如果 Promise reject（失败），await 表达式会抛出一个错误（这个错误可以被 try...catch 捕获）。

-   **恢复执行**：一旦 Promise 状态确定，async 函数会从暂停的地方恢复执行。

#### **3. await 的返回值**

-   如果 await 等待的是一个 Promise，它返回 Promise 的解决值。
-   如果 await 等待的不是一个 Promise（比如一个普通的值），它会立即返回那个值（内部会将其包装成一个已解决的 Promise）。

######  **4. 示例**

**示例 1: 等待一个 Promise**

```js
function resolveAfter2Seconds() {
  console.log("开始一个慢速操作");
  return new Promise(resolve => {
    setTimeout(() => {
      resolve("操作完成");
      console.log("慢速操作已解决");
    }, 2000);
  });
}

async function asyncCall() {
  console.log("调用 asyncCall 函数");
  const result = await resolveAfter2Seconds(); // 暂停直到 Promise 解决
  console.log(result); // 输出: "操作完成"
  console.log("asyncCall 函数结束");
}

asyncCall();
console.log("asyncCall 函数已被调用，但可能还在等待");

/*
输出顺序会是:
调用 asyncCall 函数
开始一个慢速操作
asyncCall 函数已被调用，但可能还在等待
(等待约 2 秒后)
慢速操作已解决
操作完成
asyncCall 函数结束
*/
    
```


####  **4错误处理**

使用 try...catch 来捕获 await 表达式中 Promise 的 reject。

```js
function mightFail() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        resolve("成功！");
      } else {
        reject(new Error("操作失败！"));
      }
    }, 1000);
  });
}

async function performOperation() {
  console.log("开始操作...");
  try {
    const result = await mightFail(); // 等待 Promise
    console.log(result);
  } catch (error) {
    console.error("捕获到错误:", error.message);
  }
  console.log("操作结束（无论成功或失败）。");
}

performOperation();
    
```


#### **5. 相比 .then() 的优势**

-   **更清晰的结构**：代码看起来更像同步代码，减少了回调地狱 (.then().then()...)。
-   **简化的错误处理**：可以使用标准的 try...catch 块来处理同步和异步代码中的错误。
-   **更易于调试**：在调试器中，可以像同步代码一样单步执行 await 语句。

**对比：使用 .then() vs async/await**

```js
// 使用 .then()
function fetchDataWithThen() {
  fetch('https://api.example.com/data')
    .then(response => {
      if (!response.ok) {
        throw new Error('网络响应错误');
      }
      return response.json();
    })
    .then(data => {
      console.log('数据 (then):', data);
    })
    .catch(error => {
      console.error('获取数据失败 (then):', error);
    });
}

// 使用 async/await
async function fetchDataWithAwait() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new Error('网络响应错误');
    }
    const data = await response.json(); // 等待 response.json() 这个 Promise
    console.log('数据 (await):', data);
  } catch (error) {
    console.error('获取数据失败 (await):', error);
  }
}

fetchDataWithThen();
fetchDataWithAwait();
    
```


#### **6. 并行执行多个 await**

如果直接连续使用多个 await，它们会串行执行（一个完成后再执行下一个）：

```js
async function sequentialOperations() {
  console.time("sequential");
  const result1 = await resolveAfter2Seconds(); // 等2秒
  const result2 = await resolveAfter2Seconds(); // 再等2秒
  console.log(result1, result2);
  console.timeEnd("sequential"); // 大约 4 秒
}
    
```


如果这些操作可以并行执行，应该使用 Promise.all()：

```js
async function parallelOperations() {
  console.time("parallel");
  // 同时启动两个操作
  const promise1 = resolveAfter2Seconds();
  const promise2 = resolveAfter2Seconds();

  // 等待所有操作完成
  const [result1, result2] = await Promise.all([promise1, promise2]);
  console.log(result1, result2);
  console.timeEnd("parallel"); // 大约 2 秒
}

// sequentialOperations();
// parallelOperations();
    
```

**总结：**

-   await 暂停 async 函数的执行，等待 Promise 解决。
-   它使得异步代码的写法更接近同步代码，提高了可读性。
-   必须在 async 函数内部使用（或模块顶层）。
-   使用 try...catch 来处理 await 抛出的错误。
-   对于可以并行的异步操作，使用 Promise.all() 配合 await 来提高效率。


# 浏览器进程 线程

1.  **进程 (Process):**

    -   操作系统进行资源分配和调度的基本单位。
    -   可以理解为一个正在运行的应用程序的实例。
    -   每个进程都有自己独立的内存空间，进程间通信（IPC）相对复杂和开销较大。
    -   如果一个进程崩溃，通常不会影响其他进程。

1.  **线程 (Thread):**

    -   进程内的一个执行单元，是 CPU 调度的基本单位。
    -   一个进程可以包含多个线程，这些线程共享该进程的内存空间和资源（如全局变量、文件句柄等）。
    -   线程间的通信相对容易，因为它们共享内存。
    -   如果一个线程崩溃，可能会导致整个进程崩溃。


**现代浏览器架构 (以 Chrome 为例):**

现代浏览器通常采用**多进程架构**，以提高稳定性、安全性和性能。

1.  **浏览器主进程 (Browser Process / Main Process):**

    -   **职责:**

        -   负责浏览器界面的显示与交互（地址栏、书签、前进后退按钮等）。
        -   管理各个标签页（渲染进程）的创建和销毁。
        -   处理网络请求（下载文件等）。
        -   负责文件访问、存储等。
        -   协调其他进程（如渲染进程、GPU 进程等）。

    -   **线程:** 内部也有多个线程，如 UI 线程、网络线程、存储线程等。

1.  **渲染进程 (Renderer Process / Tab Process):**

    -   **职责:**

        -   每个标签页通常对应一个独立的渲染进程（为了安全和稳定，一个崩溃不影响其他）。有时多个标签页如果来自同一站点，也可能共享一个渲染进程（Site Isolation 策略）。
        -   核心任务是把 HTML, CSS, JavaScript 转换成用户可以看到和交互的网页。
        -   解析 HTML 生成 DOM 树。
        -   解析 CSS 生成 CSSOM 树。
        -   结合 DOM 和 CSSOM 生成渲染树 (Render Tree)。
        -   布局 (Layout/Reflow) 和绘制 (Paint/Rasterize)。

    -   **线程 (渲染进程内部的关键线程):**

        -   **a. 主线程 (Main Thread):**

            -   **这是 JavaScript 代码执行的地方！**
            -   负责解析 HTML、CSS。
            -   计算样式、布局。
            -   执行 JavaScript。
            -   处理用户交互事件（点击、滚动等）。
            -   **非常繁忙，是性能瓶颈的关键。如果 JS 执行时间过长，会阻塞 UI 渲染和用户响应，导致页面卡顿。**

        -   **b. Worker 线程 (e.g., Web Workers):**

            -   允许 JavaScript 在主线程之外的后台线程中运行耗时计算，而不会阻塞主线程。
            -   Web Worker 有自己的全局上下文，不能直接访问主线程的 window 或 document 对象。
            -   通过 postMessage 和 onmessage API 与主线程通信。

        -   **c. 合成线程 (Compositor Thread):**

            -   负责将页面的各个图层（Layers）合成为最终的屏幕图像。
            -   可以独立于主线程进行工作，实现平滑的滚动和动画（如 CSS Transform 和 Opacity 动画）。

        -   **d. 光栅线程 (Raster Threads):**

            -   负责将图层信息转换为位图（像素）。

        -   **e. 定时器线程 (Timer Thread):**

            -   setTimeout 和 setInterval 由这个线程管理。当计时器到期时，它会将回调函数放入任务队列中，等待主线程的事件循环来执行。

        -   **f. 事件触发线程 (Event Trigger Thread):**

            -   当一个事件被触发时（如鼠标点击、网络请求完成），此线程会把事件处理函数添加到任务队列的队尾，等待主线程执行。

1.  **GPU 进程 (GPU Process):**

    -   负责处理 GPU 相关的任务，如 3D 绘制、硬件加速 CSS 动画等，以减轻 CPU 的负担。

1.  **插件进程 (Plugin Process):**

    -   为浏览器插件（如 Flash，虽然现在很少用了）提供运行环境。每个插件通常在独立的进程中运行。

1.  **网络进程 (Network Process):**

    -   有些浏览器会将网络请求独立为一个进程，专门负责URL请求、数据下载等。





# 宏任务 微任务队列




# Pormise面试题


# throw try catch
# 浏览器储存 Storage